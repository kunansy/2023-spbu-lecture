# Промышленное программирование

## Предисловие
1. Что такое процесс? Из чего состоит исполняемый файл?
2. Что такое операционная система? Зачем нужна и что из себя представляет?
3. Что такое докер образ, докер файл, контерейнизация и зачем это нужно?
6. Какова структура веб-сервиса?


## Приложение
Мы напишем простой веб-сервис, который будет принимать в параметрах урла имя и возвращать ответ в формате json.
JSON – это простой текстовый формат, выглядящий вот так: (картинка на слайде). Обычно в современном мире веб-сервисы общаются с его помощью.

Для веб-сервиса нам потребуется библиотека. Библиотека/фреймворк или более общее понятие зависимость -- это кем-то уже написанный код, который решает часть вашей задачи: перемножить матрицы, 
обучить дерево решений, создать веб приложение, отсортировать массив итд. В зависимости от вашего уровня заинтересованности в IT, 
какие-то из этих слов могут быть вам понятны или нет.

В качестве веб-фреймворка будем использовать FastAPI: 
Зависимости указываются в файле `requirements.txt`, ставятся вот так: `pip install -r requirements.txt`

Пишем endpoint, он обрабатывает ваш запрос, когда вы обращаетесь на сайт vk.com/feed.

Давайте запустим наше приложение локально, как это сделать?
(Выхожу к доске, рисую.)
Веб-сервисы состоят из нескольких компонентов: веб-сервер (nginx), который принимает и обрабатывает запросы: он может их отклонять,
фильтровать по IP, то есть можно ограничить доступ только с определённых адресов, защищать от DDoS, именно он 
обрабатывает зашифрованный трафик, то есть HTTPS, распределяет запросы на следующий уровень, ведь на одной машине может быть много сайтов.
Application сервер (несколько), который запускает приложение, перезапускает его в случае падения итд.
База данных, кэш, очередь итд.

(Возвращаюсь за компьютер.)
Нам нужно второе звено, ещё одна зависимость -- uvicorn:
Ставим, запускаем: `uvicorn main:app --host "127.0.0.1" --port 8001`

(картинка с коммутатором)
Что такое порт? Раньше под портами подразумевались физически разные дырочки в коммутаторе, благодаря им можно было запускать
на одном сервере множество разных приложений, понимать, к какому именно сервису обращается пользователь, можно было по порту.
Сейчас порты используются для тех же целей, но они виртуальные.

## Докер
Запустили, проверили, всё просто, но... но приложения в реальной работе большие, в них много зависимостей, нужно много настройки, 
ставить разные версии зависимостей -- ведь если вы ставите программу какой-то версии, то она в вашей системе везде будет такая, 
а иногда нужны разные версии для разных приложений.
Чтобы упростить запуск приложений в самостоятельной изолированной среде существует _докер_.

(выхожу к доске, слайд с докером)
Давайте готовить пирог. Что нам нужно? Рецепт! Чтобы пирог получался одинаково вкусным у всех, кто его готовит, рецепт должен быть
правильно написан (с правильным весом продуктов). Также чтобы приложение у всех запускалось одинаково правильно, 
нужно написать правильный "рецепт" докер файла.
(слайд с примером докерфайла)
Докерфайл -- рецепт нашего "пирога", просто текстовый файл, из которого специальная программа соберёт нам докер образ, 
"пирог", который мы сможем запустить как обычную программу. Описываем что хотим делать, сверху вниз наслаивая коржи друг на друга.
Начинаем с готового коржа (как и в случае с зависимостями, мы не пишем веб-сервис сами, в используем готовый код): здесь уже кто-то
за нас приготовил пирог попроще, установил программы и зависимости, из которых мы можем собрать пирог сложнее.
Указываем базовый образ и его версию.

Далее создаём каталог с нашим приложением, копируем файл с зависимостями, устанавливаем их, копируем код нашего приложения,
пишем команду для запуска. Если бы писали на компилируемом языке, то запустили бы компилятор и получили бы на выходе бинарный файл.

Как приезжавший пару месяцев назад Райгородский спрашивал, вас ещё не торкнуло, пока держитесь, всё понятно?

(Выхожу и рисую мужика в колпаке.)
Докерфайл написали, дальше нам нужен повар -- кто приготовит пирог.
Мы отдаём повару рецепт, он проходит по строкам сверху вниз и делает всё, что мы ему сказали. 

(Сажусь и пишу в консоли.)
Если хотите быть программистом, то привыкайте работать в консоли -- это необходимо.
`docker build -t app .` – повар, собери нам торт, назови его так, ингредиенты ищи здесь. 
В юникс системах `.` -- текущая директория, `..` -- предыдущая. То есть в этой папки ищи зависимости и код.

Запускаем, ждём. Иногда образы собираются очень долго, можно сходить кофе сделать, в массажном кресле посидеть, 
поиграть в PlayStation, короче наслаждаться работой программиста в VK.

Образ собрался.
Смотрим образы, наши готовые торты. Наш повар лентяй и эгоист, он сам хочет съесть свой торт, поэтому вызываем того же повара: 
`docker images`. Это уже собранные по рецепту пироги, которые можно есть. То есть приложения,
которые мы можем запустить: `docker run -p 8001:8001 -d app`. Помните я говорил про порты? Справа внутренний порт, слева -- внешний.
Смотрим статус контейнера, то есть запущенного образа: `docker ps -a`, смотрим логи: `docker logs app -f`.

## Облако
Локально всё работает, пора запускаться на сервере! Но для начала: (фото rack mount).
Всякий сайт или сервис размещён на сервере, то есть специальном компьютере, у которого специальный процессор, бывает
особая RAM с контролем чётности, у неё есть дополнительный 9-й бит контроля чётности, особая сеть со своими ограничениями, 
а находится он в особом месте -- ДЦ. 
Но как нам такой сервер заполучить для своих нужд? Не собирать же его? Нам нужно облако -- особый сервис, делающий всю работу за нас: 
не нужно в консоли прописывать настройки сети, системы, ИБ, бэкап, контролировать бесперебойность питания, контролировать взрывающиеся конденсаторы итд. Нам даже его не привезут! Мы его арендуем.
(Заходим и создаём инстанс в ВК облаке).

## DNS
У всех компьютеров в сети есть свой уникальный адрес -- IP, по которому мы можем обратить к нему. 
Но когда мы пишем в браузере адрес сайта, то мы пишем его имя, не указывая IP или порт, хотя можем.
(открываю веб консоль и показываю, что обращение по IP)
Как наш компьютер понимает, по какой IP обратиться? Для этого у нас есть DNS!
(слайд с ДНС)
Когда вы пишете в адресной строке имя вашей любимой соцсети (ВК), чтобы послушать музыку, то ваш компьютер
сначала обращается в особое место -- DNS-сервер, который и отдаёт IP.
Далее по этому адресу ваш компьютер обращается, а там, вспоминайте схему ранее, его ждёт веб-сервер.

Давайте дадим нашему серверу домен, (открываем reg.ru, создаём A-запись и указываем адрес.)
Нужно немного подождать, чтобы адрес связался с доменом.

## Настройка сервера
Тем временем давайте настроим докер и nginx на сервере, заходим по ssh -- особый безопасный протокол, позволяющий 
удалённо управлять сервером как локальной машиной. Заходим, ставим софт, включая certbot, который нам понадобится, 
чтобы совершенно бесплатно получить HTTPS сертификат и шифровать наш трафик.

Зальём наш образ на докерхаб, чтобы суметь откуда угодно его загрузить и использовать.
(Задаём тэг, отправляем). Загрузим его с сервера, вы можете загрузить его со своих компьютеров. 
Запустим так же, как и запускали локально -- помните, в чём прелесть докера? -- везде одинаково!

(Начинаем настраивать nginx.)
Пишем конфиг: (что такое sites-enabled/available, server_name)...
Написали, проверяем, заходит.
Запросим HTTPS сертификат: certbot.

Вот мы и получили работающий на настоящем сервере сайт, выполняющий то, что нам нужно, у которого 
есть свой домен и сертификат, обеспечивающий нам безопасное соединение с сайтом.

(слайд)
Вопросы, на которые вы уже сейчас можете ответить, попробуйте для себя продумать их:
1. В чём идея докера, ради чего его используют?
2. Из чего состоит веб-сервис?
3. Что такое облако?
4. Как происходит обращение к вашему любимому сайту по шагам?

## Перерыв 5 минут, дальше самое интересное – ОС

Что такое операционная система? 
До изобретения ОС, когда программы ещё писались на перфокартах инженерами-учёными и математиками, каждая
перфокарта, то есть программа, должна была содержать код управления задачей, как её запустить, как её завершить,
там же находился код работы с внешними у-вами, например клавиатурой, то есть буквально какие байты какой 
клавише соответствуют требовалось писать в каждой программе. В таком коде легко ошибиться,
да и писать его каждый раз не очень интересно и продуктивно.

Тогда появляется концепция ОС, цель которой -- обеспечить решение такого рода проблем (выхожу к доске и рисую котика): 
управление запущенными задачами, обеспечение их совместной работы, управление внешними у-вами, распределение RAM, ограничение
кол-ва одновременно открытых файлов etc.
Что делает ОС? Вообще всё! Запуск программы, взаимодействие её с жёстким диском, клавиатурой, сетью, программа даже сама
завершиться не может. Вообще говоря, в мультизадачных ОС программа сама имеет право только изменять данные в том фрагменте
памяти, который ей выделила ОС, но об этом далее. Для всего программе нужно просить ОС. Как просить? 
Для этого существует _системный вызов_ -- почти как обычный вызов функции в языке, только в ОС:
(слайд пример hello world на ассемблере nasm) 
Да, даже печать на экран без ОС не сделать. Здесь мы устанавливаем номер вызова 
-- 4, передаём параметры в регистры процессора и делаем syscall.
(если вам будет интересно, то я смогу на следующих занятиях объяснить это подробнее). В конце для завершения мы должны сделать
системный вызов exit. Всё это намурлыкает, то есть сделает, нам наш котик.
Если интересно, можно скомпилировать и запустить программу.
Но также существуют вызовы и функции, на которых у программы по тем или иным причинам нет прав, их может вызвать только ОС.

Switch your attention!

С ОС в общих чертах понятно, а как запускается программа? Пусть у нас есть файл особого типа и свойств, который мы называем _исполняемым_.
(обратите внимание, пока я говорю только про компилируемые языки, программы в которых не требуют наличия на машине никакого 
дополнительного ПО в виде интерпретатора, нужна только ОС). 
(все же понимают, чем отличается компиляция от интерпретации? Если нет, то рассказать).
Так вот, наш файл состоит из 3-сегментов ассемблерного кода: .data – инициализированные данные, значения, которые мы прямо прописали в 
коде: `int allQuestionsSolution = 42;`, .bss – неинициализированные данные, то есть обычные переменные, у которых заранее 
известных значений нет, но мы знаем, что они там будет, и .text – сам код, исполнение которого мы хотим.
Открываем простой hello word на С, смотрим через hexdump его код.

Что происходит, когда мы его запускаем? Создаётся _процесс_ -- особая сущность ядра ОС, запущенная или приостановленная программа
(вы могли не замечать, но процессы могут быть поставлены на паузу особым сигналом, где сигнал -- такой способ, которым ОС
позволяет управлять процессами, собственно ставить их на паузу, убивать итд, показать список сигналов в man или htop и прибить
какой-то процесс). Так вот, создаётся процесс, как? 

У нас есть на диске всё тот же файл, нужно выгрузить его в RAM (все же понимают, что это? кто понимает, поднимите руку).
Нужно выгрузить его в оперативку, для этого опять надо просить нашего котика! Делаем системный вызов mmap, который это и делает, потом
выделяем кучу – вам должны были об этом уже рассказать – куча это сумма наших сегментов .data, .bss. И автоматически создаётся стек, 
ему ничего из сегментов ассемблерного кода не соответствует.

Вопрос на засыпку! Обращение к куче медленнее обращения к стеку, почему? Это одна и та же оперативная память, она не может 
работать с разной скоростью.

Загрузили файл в RAM (на самом деле я сильно упрощаю, почти вру вам, честно говоря, но теория ОС – штука большая, а у меня время ограничено).
Загрузили файл, выделяем ресурсы процессу: память, процессорное время, доступ к файлам, к сети итд).

В итоге процесс – это задача, программа, которая может быть запущена или приостановлена (и ещё несколько состояний), имеет 
в оперативке свой код и свои данные, ему были выделены ресурсы, поставлен приоритет планировщика, и которая может общаться с ОС, 
просить её что-то сделать, в том числе обратиться к другому процессу за услугой, передать ему данные.

Сложно?

// TODO: слайд
На самом деле я бы хотел отметить одну фундаментально важную мыль, которая иногда становится для людей стоп-фактором при
входе в IT: теория всегда должна быть подкреплена пратикой. (!) Целостный мысленный образ,
то есть ваше представление о концепции или идее в голове, может быть сформировано только после того, как вы сами попробуете.
**Не повторяйте за мной все шаги букву в букву**, я бы этого не хотел, хотя презентация будет доступна,
но прочувствуйте те проблемы, которые стояли перед программистами прошлого и ради решения которых написан софт, изобретены подходы.

Попробуйте написать свой веб-сервис, собрать свой докер-образ, задеплоить его на свой сервер, ВК облако позволяет 
при регистрации на время использовать мощности без оплаты. Вы столкнётесь с трудностями, тогда
вспомните мои слова, свяжите их с реальным опытом, поймите идею, и только потом, погуглив документацию, придите к решению. 
Пробуйте и не бойтесь ошибаться!

Может показаться, что теории много, это правда, но большая часть сказанного приходит с опытом, 
с решением задач. Не нужно бросаться вызубривать все учебники по IT, которые вы найдёте в библиотеке, нет, это ни чему не приведёт.
Практикуйтесь, сами находите проблемы, которые можно решить программами, автоматизировать, и решайте. Так вы сформируете у себя
правильной программистское мышление. Вот, например, я написал бота, который парсит расписание с сайта СПбГУ и присылает мне в ТГ 
– есть проблема, есть решение.

Почему эта мысль важна? Что практика не менее значима, чем теория.
На самом деле я упоминал, что давным-давно, когда всех нас и, возможно, наших родителей ещё даже в планах не было,
программировать могли только люди с высокой научной компетенцией, глубоким знанием математики и научными степенями.
Те времена прошли, программист != математик. Более того, кто приходит в IT из матёрых математиков или "спортивных программистов",
как правило, пишут намного более посредственный код. И автор знает людей, которые честно признавались ему, что им потребовалось
много времени, чтобы избавиться от мышления "спортивного программиста" и научиться писать хороший код.

// Если вам кажется, что с обучением у вас не идёт или что это вам неинтересно, то я мог бы сказать "пробуйте ещё, у вас получится".
// Может быть, но если вы пришли к этой мысли, то очевидно, уже пробовали и не получилось. 

(слайд с цитатой Кириенко)
Не отчаивайтесь, у каждого из нас свой путь. Автор собеседовался в ВК-рекламу, общался с их CTO, и понял:
не важно, какой у вас диплом, откуда вы родом, важно – что у вас между ушей.

Спасибо за внимание, я готов ответить на ваши вопросы.

